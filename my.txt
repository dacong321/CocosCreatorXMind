=====================================================================================================
通过域名查找ip地址就是dns解析
网络7层协议，每一层都有每一层的协议
http协议要基于传输层的tcp/ip协议来实现
物理层： 物理设备
数据链路层： 软件+物理设备（硬件）创建的电路连接（基础的数据传输）
网络层： 数据在节点（网络设备）之间创建逻辑链路
-----------------------------------------------------------------
传输层：向高层屏蔽了下层的通讯数据的细节，两个协议 TCP/IP、UDP
会话层：session Layer，负责两个实体 之间的会话 连接确保点到点之间的传输不被中断。
表示层：加密解密编码格式转换
应用层：http协议，构建在TCP协议之上，为应用软件提供了各种服务，屏蔽了网络传输的相关细节-具体网络传输细节也不需要知道。
-----------------------------------------------------------------
http 与 webSocket 和  socket.io
http ：      client ==> server  靠客户端发起请求，然后服务端收到请求在进行回应。
webSocket ： server  <==> client 双向。基于TCP的一种新的网络协议。
socket.io ： 封装了WebSocket以及其他的一些协议，并且实现了WebSocket的服务端代码。

https://www.jianshu.com/p/00e4decb7ac2
https://www.cnblogs.com/ostrich-sunshine/p/7474471.html
-----------------------------------------------------------------
NodeJS中
1. __dirname2 ： Node.js 中，__dirname 总是指向被执行 js 文件的绝对路径，所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。
2. ./ 会返回你执行 node 命令的路径，例如你的工作路径。
3. 有一个特殊情况是在 require() 中使用 ./ 时，这时的路径就会是含有 require() 的脚本文件的相对路径。

-----------------------------------------------------------------
svn使用：
新建一个svn地址：
1. 在目标工程中 ,  .svn 目录下，鼠标右键，选择Repo-browser。（和目标工程无关，其实就是为了打开 svn 浏览器）
2. 在弹出框内 单击选择相应文件夹， 新建 add file ， 会在URl栏出现svn地址
3. 在本地相对合适的位置 check out 出来，进而在文件内进行添加删除文件。（.svn 同目录下）



在主工程中添加具体游戏软链接：
在主工程引用的位置 添加，Tortoise SVN -->  peoperties  -->  添加工程的软链接（svn:externals）
在1处（即svn浏览器中），会显示出 对应位置的软链接，标识大概为蓝色J箭头显示。
-----------------------------------------------------------------
----------------------------------------------------------
简单介绍工作流：
cocoscreator的底层是cocos2d-x 
1. 外部导入资源。资源管理器创建资源（场景、预置、动画、脚本、粒子）
2. 搭建场景.fire文件
3. 场景中的节点挂载，内置组件或自定义组件，控制游戏逻辑
4. 脚本组件化 和开放式插件
5. 数据驱动的工作流

项目结构：
assets：所有的都在这，本地资源脚本和第三方库
library：无用（导入自动生成信息）
local: 无用（本地配置）
packages： 放置 此项目的自定义扩展插件
settings： 项目设置
temp：无用
project.json：工程配置文件
build：构建目标  项目->构建发布时产生的
----------------------------------------------------------

编辑器：
资源管理器
场景编辑器
层级管理器
属性检查器
控件库
工具栏
设置
项目设置

----------------------------------------------------------
代码编辑环境配置：
----------------------------------------------------------
第一个游戏：
Canvas： 画布
prefab：








----------------------------------------------------------
基本工作流程：
配置资源--> 
配置场景-->
配置脚本-->
一键接入第三方
发布跨平台

----------------------------------------------------------
=====================================================================================================
配置资源：
一.在资源管理器中： 创建场景 保存场景 切换场景 
切换场景中释放资源:1. cc.loader.release
	           2. 场景的自动释放功能
如切换场景不释放资源，内存越来越大。
若启用了2的场景自动释放功能，我们想让一部分资源不被释放，可使用cc.loader.setAutoRelease或者cc.loade.setAutoReleaseRecursively保留资源.
延迟加载资源
======================================================
二.在资源管理器中： 添加贴图资源
Texture和它的子资源SpriteFrame
Atlas和它的多个子资源SpriteFrame
使用SpriteFrame
======================================================
三.在资源管理器中： 添加预制资源
创建、保存。还原预置
预制体的自动同步和手动同步
======================================================
四.在资源管理器中： 添加Atlas（图集资源）后，资源管理器中显示Atlas和它的多个子资源SpriteFrame
creator提供了自动图集功能，将碎图打成Atlas
======================================================
五.在资源管理器中： “创建”自动图集资源Auto Atlas。
六.在资源管理器中：压缩纹理
七.在资源管理器中：创建艺术数字资源(LabelAtlas)
八.在资源管理器中：跨项目导入 导出资源
九.在资源管理器中：图像资源的自动剪裁
十.在资源管理器中：创建和使用脚本组件
======================================================
十一.在资源管理器中：创建和使用字体资源
系统字体
动态字体
位图字体
直接创建label渲染组件，将字体拖入
======================================================
十二. 粒子资源
======================================================
十三.在资源管理器中：创建和使用声音资源
1.属性检查器内会有加载模式的选项
2.使用cc.loader.load
======================================================
十四.在资源管理器中：创建和使用Spine、DragonBone 骨骼动画资源
十五.在资源管理器中：创建和使用瓦片图资源
======================================================
十六.在资源管理器中的asset目录下将的所有.json文件，都会导入为cc.JsonAsset
1.直接为组件关联一个json
2.也可以动态加载 cc.loader.loadRes("路径", function(err, leixing变量){}); //这里的类型变量为jsonAsset
十七.文本资源： 同上
======================================================



----------------------------------------------------------
=====================================================================================================
配置场景：
一.组件式开发（组合而非继承）如Sprite节点 是由Node节点和Sprite组件组合而成的。
节点是承载组件的实体，组件来让节点具有各式各样的表现。
二.坐标系
三.层级管理器，节点层级
四.Canvas 渲染根节点
五.摄像机
----------------------------------------------------------
=====================================================================================================




配置脚本：
一.创建组件脚本：创建js脚本挂载在节点上。
======================================================
二.使用cc.Class();声明一个类型，如let 类型 = cc.Class();
    声明出来的类型可以实例化对象如 var obj = new 类型();
    cc是一个对象，调用cc对象的Class方法，class方法的参数是一个匿名对象，匿名对象在properties中包含了一个匿名对象，匿名对象内 使用key：value的方式设置了key属性，当然value也可以是一个匿名对象

1判断类型
2构造函数
3实例方法
4继承
5父构造函数
6脚本中声明属性
  简单声明
  完整声明
  数组声明
  get/set 声明
======================================================
三.访问节点和组件 
1.获得组件所在的节点 this.node
2.获得其它组件 this.node.getComponent(cc.Sprite); 
3.利用属性检查器设置组件、利用属性检查器设置节点
4.查找子节点 this.node.children; cc.find(); getChildByName();
5.访问已有变量里的值：
①.通过全局变量访问
②.通过require模块访问
======================================================
四. 模块化脚本
模块化：引用其它文件，访问其它文件导出的参数，
         调用其它文件导出的方法
         使用其它文件导出的类型
         使用或继承其它组件Component
与NodeJs几乎相同的CommonJS标准来实现模块化
  每个单独的脚本文件就构成一个模块
  每个模块就是一个单独的作用域
  以同步的require 方法来引用其它模块
  设置module.exports 为导出的 变量
======================================================
require:
可在脚本任意地方任意时刻调用
游戏开始时会自动require所有脚本，这时每个模块内部定义的代码就会被执行一次，之后无论又被require了几次，返回的始终是同一份实例
require 实际上获取的是 目标脚本中的 moudule.exports变量
======================================================
定义模块：
①定义组件：当在脚本中 cc.Class({extends: cc.Component,});声明了一个组件，Creator会默认把他们导出，其它模块直接require这个模块 就可以直接使用这个组件。
②定义普通JavaScript模块
不单可以定义组件，还可导出任意js对象
======================================================
导出变量： module.exports默认是一个空对象{}， 可以直接往里面加字段。  module.exports.key = value;
module.exports的值可以是任意JS类型
======================================================
封装私有变量：
每个脚本都是一个单独的作用域， 在cc.class();外设置的  var 局部变量是私有变量，只能在脚本中使用，外部模块访问不到。
======================================================
五. 插件脚本
资源管理器选中任意脚本， 属性检查器看到导入为插件 这一设置界面。
对于组件脚本而言默认为普通脚本。
对于第三方或底层插件 可以设置脚本为插件脚本。

普通脚本：可以require。脚本内声明的局部变量不会暴露到全局。use strict 被强制开启。项目构建阶段所有脚本都会被打包成单个脚本文件。
插件脚本：不可require。脚本内不再任何函数内声明的变量 都默认为全局。use strict需要声明，否则未定义的额变量一旦赋值就会变成全局变量。项目构建阶段不进行打包。

脚本加载顺序：Cocos2d引擎--> 插件脚本--> 普通脚本。

======================================================
六.CCClass进阶
CCClass： 使用cc.Class声明的类
原型对象：调用cc.Class 时传入的字面量参数，原型对象里面的参数可以省略，只需声明用的到的部分。
实例成员：成员变量 、 成员方法
静态成员：static 的静态成员和静态方法
运行时：
序列化：解析内存中的对象，将他的信息编码为一个特殊的字符串 ，以便保存到硬盘上或传输到其他地方。

类名： 使用getClassByName方法可以用来查找类名。
       使用cc.js.getClassByName(JsName);来查找对应的类。
判断实例： instanceof();
判断类: cc.isChildClass();
成员： 实例变量、实例方法
       静态变量、静态方法 在Class的原型对象参数中设置keyValue如 static:{}; 或者。。。
       私有的静态成员（局部变量）
       除了私有的静态成员，其它静态成员会被子类继承，继承时会将父类的静态变量 浅拷贝 给子类
继承：无论子类是否有定义构造函数，子类实例化前父构造函数都会被自动调用。
重写： 所有成员方法都是虚方法，子类方法可以直接重写父类方法
属性： 属性是特殊的实例变量，能够显示在属性检查器中，也能被序列化
属性参数： 所有属性都是可选的，但是必须要有default get set中的一个
======================================================
七. 分包加载
以文件夹为单位进行分包加载。
选中文件夹->属性管理器选中分包加载-->点击应用确认
子包名就是文件名
子包名会在加载子包的时候 作为加载的名字传入

分包的作用只会在构建后才会体现。构建后在sbupackages 文件夹下生成 对应子包名文件夹，文件夹下的代码会合并成一个脚本文件，资源会移动到子目录下。

加载子包， 系统会提供一个统一的api来加载子包文件里面的资源cc.loader.downloader.loadSubpackage('包名', function(){});
如果子包被加载成功，则子包中的脚本会自动运行，之后就像使用主包一样的使用子包了。
======================================================
八. 对象池cc.NodePoor
九. 动作系统：是基于Node的

======================================================
android：

小知识1：
this project will support instant apps
这个项目将支持即时应用
无需安装app，直接得到代码环境执行的结果。
把所有代码和资源放到instant app模块，用户即时访问时 关联这个模块。

小知识2：
sync project with gradle files
同步项目与gradle文件

小知识3：
Android Studio “Sync project with Gradle Files”按钮消失问题?
发现工程中少了个.iml文件，看来这一切异常基本和这个iml文件有关系.只要重启android studio打开该项目即可生成iml。

小知识4:
iml文件的用途?
用英语在stackoverflow上试试，第一条便是：What are iml files in Android Studio?
IML是由IntelliJ IDEA创建的模块文件，这是一个用于开发Java应用程序的IDE。它存储有关开发模块的信息，可能是Java、插件、Android或Maven组件;保存模块路径、依赖项和其他设置。
然而，Gradle并不是IntelliJ IDEA的本地项目模型――它是独立的，保存在.iml文件和. IDEA /目录中的元数据中。在Android Studio中，这些东西大多是由Gradle构建脚本生成的，这就是为什么当你修改像build. Gradle这样的文件时，你会被提示“与Gradle文件同步项目”。这也是为什么您不必费心将.iml文件或.idea/放入版本控制中，因为它们的内容将被重新生成。

小知识5：
File 目录 ---> invalidate caches/restart ---invalidate and restart
即缓存失效重启androidStudio

小知识6：
Android Studio是从build.gradle里面定义的Maven 仓库服务器上下载library的。
Apache Maven是Apache开发的一个工具，提供了用于贡献library的文件服务器。
总的来说，只有两个标准的Android library文件服务器：jcenter 和 Maven Central。

小知识7：
jcenter和Maven Central两个标准的仓库。

小知识8：
为什么webView.loadUrl("file:///android_asset/example.html")是这种格式,
找assets文件夹下的example.html文件加载。

小知识9：
讲解findViewById的用法&是做什么的
安卓编程的定位函数，主要是引用.R文件里的引用名。
一般在R.java文件里系统会自动帮你给出你在XML里定义的ID或者Layout里面的名称，
例如：Button button=(Button)findViewById(R.id.button01);
这样就引用了XML（res里的布局文件）文件里面的button，使得在写.java的按钮时能与XML里的一致。

小知识10：
R.java是什么？
R.java文件自动生成，用来定义Android程序中所有各类型的资源的的索引。
有控件的id的索引，string字符串资源的索引，layout的索引，drawable资源索引等等
用户可以通过“R.资源类名.索引”来调用定义的资源



























