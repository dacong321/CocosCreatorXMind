=====================================================================================================
通过域名查找ip地址就是dns解析
网络7层协议，每一层都有每一层的协议
http协议要基于传输层的tcp/ip协议来实现
物理层： 物理设备
数据链路层： 软件+物理设备（硬件）创建的电路连接（基础的数据传输）
网络层： 数据在节点（网络设备）之间创建逻辑链路
-----------------------------------------------------------------
传输层：向高层屏蔽了下层的通讯数据的细节，两个协议 TCP/IP、UDP
会话层：session Layer，负责两个实体 之间的会话 连接确保点到点之间的传输不被中断。
表示层：加密解密编码格式转换
应用层：http协议，构建在TCP协议之上，为应用软件提供了各种服务，屏蔽了网络传输的相关细节-具体网络传输细节也不需要知道。
-----------------------------------------------------------------
http 与 webSocket 和  socket.io
http ：      client ==> server  靠客户端发起请求，然后服务端收到请求在进行回应。
webSocket ： server  <==> client 双向。基于TCP的一种新的网络协议。
socket.io ： 封装了WebSocket以及其他的一些协议，并且实现了WebSocket的服务端代码。

https://www.jianshu.com/p/00e4decb7ac2
https://www.cnblogs.com/ostrich-sunshine/p/7474471.html
-----------------------------------------------------------------
NodeJS中
1. __dirname2 ： Node.js 中，__dirname 总是指向被执行 js 文件的绝对路径，所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。
2. ./ 会返回你执行 node 命令的路径，例如你的工作路径。
3. 有一个特殊情况是在 require() 中使用 ./ 时，这时的路径就会是含有 require() 的脚本文件的相对路径。

-----------------------------------------------------------------
svn使用：
新建一个svn地址：
1. 在目标工程中 ,  .svn 目录下，鼠标右键，选择Repo-browser。（和目标工程无关，其实就是为了打开 svn 浏览器）
2. 在弹出框内 单击选择相应文件夹， 新建 add file ， 会在URl栏出现svn地址
3. 在本地相对合适的位置 check out 出来，进而在文件内进行添加删除文件。（.svn 同目录下）



在主工程中添加具体游戏软链接：
在主工程引用的位置 添加，Tortoise SVN -->  peoperties  -->  添加工程的软链接（svn:externals）
在1处（即svn浏览器中），会显示出 对应位置的软链接，标识大概为蓝色J箭头显示。
-----------------------------------------------------------------
----------------------------------------------------------
简单介绍工作流：
cocoscreator的底层是cocos2d-x 
1. 外部导入资源。资源管理器创建资源（场景、预置、动画、脚本、粒子）
2. 搭建场景.fire文件
3. 场景中的节点挂载，内置组件或自定义组件，控制游戏逻辑
4. 脚本组件化 和开放式插件
5. 数据驱动的工作流

项目结构：
assets：所有的都在这，本地资源脚本和第三方库
library：无用（导入自动生成信息）
local: 无用（本地配置）
packages： 放置 此项目的自定义扩展插件
settings： 项目设置
temp：无用
project.json：工程配置文件
build：构建目标  项目->构建发布时产生的
----------------------------------------------------------

编辑器：
资源管理器
场景编辑器
层级管理器
属性检查器
控件库
工具栏
设置
项目设置

----------------------------------------------------------
代码编辑环境配置：
----------------------------------------------------------
第一个游戏：
Canvas： 画布
prefab：
----------------------------------------------------------
基本工作流程：
配置资源--> 
配置场景-->
配置脚本-->
一键接入第三方
发布跨平台

----------------------------------------------------------
=====================================================================================================
配置资源：
一.在资源管理器中： 创建场景 保存场景 切换场景 
切换场景中释放资源:1. cc.loader.release
	           2. 场景的自动释放功能
如切换场景不释放资源，内存越来越大。
若启用了2的场景自动释放功能，我们想让一部分资源不被释放，可使用cc.loader.setAutoRelease或者cc.loade.setAutoReleaseRecursively保留资源.
延迟加载资源
======================================================
二.在资源管理器中： 添加贴图资源
Texture和它的子资源SpriteFrame
Atlas和它的多个子资源SpriteFrame
使用SpriteFrame
======================================================
三.在资源管理器中： 添加预制资源
创建、保存。还原预置
预制体的自动同步和手动同步
======================================================
四.在资源管理器中： 添加Atlas（图集资源）后，资源管理器中显示Atlas和它的多个子资源SpriteFrame
creator提供了自动图集功能，将碎图打成Atlas
======================================================
五.在资源管理器中： “创建”自动图集资源Auto Atlas。
六.在资源管理器中：压缩纹理
七.在资源管理器中：创建艺术数字资源(LabelAtlas)
八.在资源管理器中：跨项目导入 导出资源
九.在资源管理器中：图像资源的自动剪裁
十.在资源管理器中：创建和使用脚本组件
======================================================
十一.在资源管理器中：创建和使用字体资源
系统字体
动态字体
位图字体
直接创建label渲染组件，将字体拖入
======================================================
十二. 粒子资源
======================================================
十三.在资源管理器中：创建和使用声音资源
1.属性检查器内会有加载模式的选项
2.使用cc.loader.load
======================================================
十四.在资源管理器中：创建和使用Spine、DragonBone 骨骼动画资源
十五.在资源管理器中：创建和使用瓦片图资源
======================================================
十六.在资源管理器中的asset目录下将的所有.json文件，都会导入为cc.JsonAsset
1.直接为组件关联一个json
2.也可以动态加载 cc.loader.loadRes("路径", function(err, leixing变量){}); //这里的类型变量为jsonAsset
十七.文本资源： 同上
======================================================
----------------------------------------------------------
=====================================================================================================
配置场景：
一.组件式开发（组合而非继承）如Sprite节点 是由Node节点和Sprite组件组合而成的。
节点是承载组件的实体，组件来让节点具有各式各样的表现。
二.坐标系
三.层级管理器，节点层级
四.Canvas 渲染根节点
五.摄像机

----------------------------------------------------------
=====================================================================================================
配置脚本：
一.创建组件脚本：创建js脚本挂载在节点上。
======================================================
二.使用cc.Class();声明一个类型，如let 类型 = cc.Class();
    声明出来的类型可以实例化对象如 var obj = new 类型();
    cc是一个对象，调用cc对象的Class方法，class方法的参数是一个匿名对象，匿名对象在properties中包含了一个匿名对象，匿名对象内 使用key：value的方式设置了key属性，当然value也可以是一个匿名对象

1判断类型
2构造函数
3实例方法
4继承
5父构造函数
6脚本中声明属性
  简单声明
  完整声明
  数组声明
  get/set 声明
======================================================
三.访问节点和组件 
1.获得组件所在的节点 this.node
2.获得其它组件 this.node.getComponent(cc.Sprite); 
3.利用属性检查器设置组件、利用属性检查器设置节点
4.查找子节点 this.node.children; cc.find(); getChildByName();
5.访问已有变量里的值：
①.通过全局变量访问
②.通过require模块访问
======================================================
四. 模块化脚本
模块化：引用其它文件，访问其它文件导出的参数，
         调用其它文件导出的方法
         使用其它文件导出的类型
         使用或继承其它组件Component
与NodeJs几乎相同的CommonJS标准来实现模块化
  每个单独的脚本文件就构成一个模块
  每个模块就是一个单独的作用域
  以同步的require 方法来引用其它模块
  设置module.exports 为导出的 变量
======================================================
require:
可在脚本任意地方任意时刻调用
游戏开始时会自动require所有脚本，这时每个模块内部定义的代码就会被执行一次，之后无论又被require了几次，返回的始终是同一份实例
require 实际上获取的是 目标脚本中的 moudule.exports变量
======================================================
定义模块：
①定义组件：当在脚本中 cc.Class({extends: cc.Component,});声明了一个组件，Creator会默认把他们导出，其它模块直接require这个模块 就可以直接使用这个组件。
②定义普通JavaScript模块
不单可以定义组件，还可导出任意js对象
======================================================
导出变量： module.exports默认是一个空对象{}， 可以直接往里面加字段。  module.exports.key = value;
module.exports的值可以是任意JS类型
======================================================
封装私有变量：
每个脚本都是一个单独的作用域， 在cc.class();外设置的  var 局部变量是私有变量，只能在脚本中使用，外部模块访问不到。
======================================================
五. 插件脚本
资源管理器选中任意脚本， 属性检查器看到导入为插件 这一设置界面。
对于组件脚本而言默认为普通脚本。
对于第三方或底层插件 可以设置脚本为插件脚本。

普通脚本：可以require。脚本内声明的局部变量不会暴露到全局。use strict 被强制开启。项目构建阶段所有脚本都会被打包成单个脚本文件。
插件脚本：不可require。脚本内不再任何函数内声明的变量 都默认为全局。use strict需要声明，否则未定义的额变量一旦赋值就会变成全局变量。项目构建阶段不进行打包。

脚本加载顺序：Cocos2d引擎--> 插件脚本--> 普通脚本。

----------------------------------------------------------
=====================================================================================================
六.CCClass进阶
CCClass： 使用cc.Class声明的类
原型对象：调用cc.Class 时传入的字面量参数，原型对象里面的参数可以省略，只需声明用的到的部分。
实例成员：成员变量 、 成员方法
静态成员：static 的静态成员和静态方法
运行时：
序列化：解析内存中的对象，将他的信息编码为一个特殊的字符串 ，以便保存到硬盘上或传输到其他地方。

类名： 使用getClassByName方法可以用来查找类名。
       使用cc.js.getClassByName(JsName);来查找对应的类。
判断实例： instanceof();
判断类: cc.isChildClass();
成员： 实例变量、实例方法
       静态变量、静态方法 在Class的原型对象参数中设置keyValue如 static:{}; 或者。。。
       私有的静态成员（局部变量）
继承：父构造函数，
















