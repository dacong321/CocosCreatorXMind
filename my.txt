=====================================================================================================
通过域名查找ip地址就是dns解析
网络7层协议，每一层都有每一层的协议
http协议要基于传输层的tcp/ip协议来实现
物理层： 物理设备
数据链路层： 软件+物理设备（硬件）创建的电路连接（基础的数据传输）
网络层： 数据在节点（网络设备）之间创建逻辑链路
-----------------------------------------------------------------
传输层：向高层屏蔽了下层的通讯数据的细节，两个协议 TCP/IP、UDP
会话层：session Layer，负责两个实体 之间的会话 连接确保点到点之间的传输不被中断。
表示层：加密解密编码格式转换
应用层：http协议，构建在TCP协议之上，为应用软件提供了各种服务，屏蔽了网络传输的相关细节-具体网络传输细节也不需要知道。
-----------------------------------------------------------------
http 与 webSocket 和  socket.io
http ：      client ==> server  靠客户端发起请求，然后服务端收到请求在进行回应。
webSocket ： server  <==> client 双向。基于TCP的一种新的网络协议。
socket.io ： 封装了WebSocket以及其他的一些协议，并且实现了WebSocket的服务端代码。

https://www.jianshu.com/p/00e4decb7ac2
https://www.cnblogs.com/ostrich-sunshine/p/7474471.html
-----------------------------------------------------------------
NodeJS中
1. __dirname2 ： Node.js 中，__dirname 总是指向被执行 js 文件的绝对路径，所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。
2. ./ 会返回你执行 node 命令的路径，例如你的工作路径。
3. 有一个特殊情况是在 require() 中使用 ./ 时，这时的路径就会是含有 require() 的脚本文件的相对路径。

-----------------------------------------------------------------
svn使用：
新建一个svn地址：
1. 在目标工程中 ,  .svn 目录下，鼠标右键，选择Repo-browser。（和目标工程无关，其实就是为了打开 svn 浏览器）
2. 在弹出框内 单击选择相应文件夹， 新建 add file ， 会在URl栏出现svn地址
3. 在本地相对合适的位置 check out 出来，进而在文件内进行添加删除文件。（.svn 同目录下）



在主工程中添加具体游戏软链接：
在主工程引用的位置 添加，Tortoise SVN -->  peoperties  -->  添加工程的软链接（svn:externals）
在1处（即svn浏览器中），会显示出 对应位置的软链接，标识大概为蓝色J箭头显示。
-----------------------------------------------------------------
----------------------------------------------------------
简单介绍工作流：
cocoscreator的底层是cocos2d-x 
1. 外部导入资源。资源管理器创建资源（场景、预置、动画、脚本、粒子）
2. 搭建场景.fire文件
3. 场景中的节点挂载，内置组件或自定义组件，控制游戏逻辑
4. 脚本组件化 和开放式插件
5. 数据驱动的工作流

项目结构：
assets：所有的都在这，本地资源脚本和第三方库
library：无用（导入自动生成信息）
local: 无用（本地配置）
packages： 放置 此项目的自定义扩展插件
settings： 项目设置
temp：无用
project.json：工程配置文件
build：构建目标  项目->构建发布时产生的
----------------------------------------------------------

编辑器：
资源管理器
场景编辑器
层级管理器
属性检查器
控件库
工具栏
设置
项目设置

----------------------------------------------------------
代码编辑环境配置：
----------------------------------------------------------
第一个游戏：
Canvas： 画布
prefab：
----------------------------------------------------------
基本工作流程：
配置资源--> 
配置场景-->
配置脚本-->
一键接入第三方
发布跨平台


配置资源：
一.在资源管理器中： 创建场景 保存场景 切换场景 
切换场景中释放资源:1. cc.loader.release
	           2. 场景的自动释放功能
如切换场景不释放资源，内存越来越大。
若启用了2的场景自动释放功能，我们想让一部分资源不被释放，可使用cc.loader.setAutoRelease或者cc.loade.setAutoReleaseRecursively保留资源.
延迟加载资源
二.在资源管理器中： 添加贴图资源
Texture和它的子资源SpriteFrame
Atlas和它的多个子资源SpriteFrame
使用SpriteFrame
三.在资源管理器中： 添加预制资源
创建、保存。还原预置
预制体的自动同步和手动同步
四.在资源管理器中： 添加Atlas（图集资源）后，资源管理器中显示Atlas和它的多个子资源SpriteFrame
creator提供了自动图集功能，将碎图打成Atlas
五.在资源管理器中： “创建”自动图集资源Auto Atlas。
六.在资源管理器中：压缩纹理
七.在资源管理器中：创建艺术数字资源(LabelAtlas)
八.在资源管理器中：跨项目导入 导出资源
九.在资源管理器中：图像资源的自动剪裁
十.在资源管理器中：创建和使用脚本组件
十一.在资源管理器中：创建和使用字体资源
系统字体
动态字体
位图字体
直接创建label渲染组件，将字体拖入
十二. 粒子资源
十三.在资源管理器中：创建和使用声音资源
1.属性检查器内会有加载模式的选项
2.使用cc.loader.load
十四.在资源管理器中：创建和使用Spine、DragonBone 骨骼动画资源
十五.在资源管理器中：创建和使用瓦片图资源
十六.在资源管理器中的asset目录下将的所有.json文件，都会导入为cc.JsonAsset
1.直接为组件关联一个json
2.也可以动态加载 cc.loader.loadRes("路径", function(err, leixing变量){}); //这里的类型变量为jsonAsset
十七.文本资源： 同上


配置场景：
一.组件式开发（组合而非继承）如Sprite节点 是由Node节点和Sprite组件组合而成的。
节点是承载组件的实体，组件来让节点具有各式各样的表现。
二.坐标系
三.层级管理器，节点层级
四.Canvas 渲染根节点
五.摄像机


配置脚本：
一.创建组件脚本：创建js脚本挂载在节点上。
二.使用cc.Class();声明一个类型，如let 类型 = cc.Class();
    声明出来的类型可以实例化对象如 var obj = new 类型();

1判断类型
2构造函数
3实例方法
4继承
5父构造函数
6脚本中声明属性
  简单声明
  完整声明
  数组声明
  get/set 声明
三.访问节点和组件
1.获得组件所在的节点 this.node
2.获得其它组件 this.node.getComponent(cc.Sprite); 
3.利用属性检查器设置组件、利用属性检查器设置节点
4.查找子节点 this.node.children; cc.find(); getChildByName();
5.访问已有变量里的值：
一.通过全局变量访问
二.通过require模块访问








